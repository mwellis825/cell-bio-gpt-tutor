<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>H5P Viewer (AMD-safe)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Local CSS (fonts 404s are harmless) -->
  <link rel="stylesheet" href="./h5p.css" />
  <style>
    html,body{margin:0;height:100%;background:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #app{min-height:100vh}
    .err{color:#b00;padding:1rem;line-height:1.5}
    .hint{padding:.75rem 1rem;background:#f6f8fa;border:1px solid #e5e7eb;border-radius:.5rem;margin:1rem}
    code{background:#f3f4f6;padding:0 .25rem;border-radius:.25rem}
  </style>

  <script>
    // 1) H5PIntegration must exist BEFORE loading bundles
    window.H5PIntegration = {
      baseUrl: location.origin + location.pathname.replace(/\/[^\/]*$/, ''),
      url: location.href,
      siteUrl: location.origin,
      hubIsEnabled: false,
      disableHub: true,
      postUserStatistics: false,
      saveFreq: false,
      l10n: { H5P: { fullscreen: "Fullscreen", exitFullscreen: "Exit fullscreen" } },
      ajax: { setFinished: "", contentUserData: "" },
      libraryUrl: "./",
      core: { scripts: [], styles: [] },
      loadedJs: [], loadedCss: [],
      contents: {}
    };

    // 2) Helpers
    function qp(n){ const u=new URL(location.href); return u.searchParams.get(n); }
    function loadScript(src){
      return new Promise((resolve,reject)=>{
        const s=document.createElement('script');
        s.src = src;               // keep URLs clean to avoid double loads
        s.onload = ()=>{ console.log('Loaded', src); resolve(); };
        s.onerror = ()=>reject(new Error('Failed to load: '+src));
        document.head.appendChild(s);
      });
    }

    // 3) Temporarily neutralize AMD/CJS so UMD attaches to window
    function neutralizeModuleGlobals(){
      const stash = {
        define:    Object.prototype.hasOwnProperty.call(window,'define')    ? window.define    : undefined,
        require:   Object.prototype.hasOwnProperty.call(window,'require')   ? window.require   : undefined,
        module:    Object.prototype.hasOwnProperty.call(window,'module')    ? window.module    : undefined,
        exports:   Object.prototype.hasOwnProperty.call(window,'exports')   ? window.exports   : undefined
      };
      // Only undefine if functions/objects that could trick UMD:
      if (typeof window.define  !== 'undefined') { try{ delete window.define; }  catch{} window.define  = undefined; }
      if (typeof window.require !== 'undefined') { try{ delete window.require; } catch{} window.require = undefined; }
      if (typeof window.module  !== 'undefined') { try{ delete window.module; }  catch{} window.module  = undefined; }
      if (typeof window.exports !== 'undefined') { try{ delete window.exports; } catch{} window.exports = undefined; }
      return stash;
    }
    function restoreModuleGlobals(stash){
      if (stash.define  !== undefined) window.define  = stash.define;  else try{ delete window.define; }  catch{}
      if (stash.require !== undefined) window.require = stash.require; else try{ delete window.require; } catch{}
      if (stash.module  !== undefined) window.module  = stash.module;  else try{ delete window.module; }  catch{}
      if (stash.exports !== undefined) window.exports = stash.exports; else try{ delete window.exports; } catch{}
    }

    // Loud error capture
    window.addEventListener('error', e => console.error('Window error:', e.error || e.message || e));
    window.addEventListener('unhandledrejection', e => console.error('Unhandled promise rejection:', e.reason || e));
  </script>

  <!-- 4) Load bundles in document order (main first, then frame) -->
  <script>
    (async function preloadBundles(){
      const stash = neutralizeModuleGlobals();
      try {
        await loadScript('./main.bundle.js');
        await loadScript('./frame.bundle.js');
      } catch (e) {
        console.error(e);
      } finally {
        restoreModuleGlobals(stash);
      }
    })();
  </script>
</head>
<body>
  <div id="app"></div>

  <script>
    (function boot(){
      const app = document.getElementById('app');
      const src = qp('src'); // URL or data:application/zip;base64,... to a .h5p
      if (!src) {
        app.innerHTML = '<div class="hint">No H5P source. Use <code>?src=&lt;url-to-your.h5p&gt;</code> (or a data: URL).</div>';
        return;
      }

      let tries = 0;
      (function waitReady(){
        tries++;
        const HS = window.H5PStandalone || window['h5p-standalone'];
        if (HS && typeof HS.display === 'function') {
          console.log('Detected global =', window.H5PStandalone ? 'H5PStandalone' : 'h5p-standalone');
          try { HS.display('#app', { h5pContent: src }); }
          catch(e){ app.innerHTML = '<p class="err">Could not initialize H5P: '+(e?.message||e)+'</p>'; }
        } else if (tries < 240) {
          setTimeout(waitReady, 50); // wait up to ~12s
        } else {
          console.log('typeof H5PStandalone =', typeof window.H5PStandalone);
          console.log('typeof window["h5p-standalone"] =', typeof window['h5p-standalone']);
          app.innerHTML = '<p class="err">H5P API not ready. The bundles likely registered as AMD/CommonJS modules instead of a window global. The viewer now neutralizes AMD/CJS during load. If this persists, double-check the two JS files are the <em>standalone dist</em> files from <code>h5p-standalone@1.3.0/dist</code> (not HTML, not source builds).</p>';
        }
      })();
    })();
  </script>
</body>
</html>
